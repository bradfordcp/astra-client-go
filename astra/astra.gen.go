// Package astra provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package astra

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for DatabaseAvailableActions.
const (
	DatabaseAvailableActionsAddDatacenters DatabaseAvailableActions = "addDatacenters"

	DatabaseAvailableActionsAddKeyspace DatabaseAvailableActions = "addKeyspace"

	DatabaseAvailableActionsAddTable DatabaseAvailableActions = "addTable"

	DatabaseAvailableActionsGetCreds DatabaseAvailableActions = "getCreds"

	DatabaseAvailableActionsLaunchMigrationProxy DatabaseAvailableActions = "launchMigrationProxy"

	DatabaseAvailableActionsPark DatabaseAvailableActions = "park"

	DatabaseAvailableActionsRemoveKeyspace DatabaseAvailableActions = "removeKeyspace"

	DatabaseAvailableActionsRemoveMigrationProxy DatabaseAvailableActions = "removeMigrationProxy"

	DatabaseAvailableActionsResetPassword DatabaseAvailableActions = "resetPassword"

	DatabaseAvailableActionsResize DatabaseAvailableActions = "resize"

	DatabaseAvailableActionsTerminate DatabaseAvailableActions = "terminate"

	DatabaseAvailableActionsTerminateDatacenter DatabaseAvailableActions = "terminateDatacenter"

	DatabaseAvailableActionsUnpark DatabaseAvailableActions = "unpark"
)

// Defines values for DatabaseInfoCloudProvider.
const (
	DatabaseInfoCloudProviderAWS DatabaseInfoCloudProvider = "AWS"

	DatabaseInfoCloudProviderAZURE DatabaseInfoCloudProvider = "AZURE"

	DatabaseInfoCloudProviderGCP DatabaseInfoCloudProvider = "GCP"
)

// Defines values for DatabaseInfoTier.
const (
	DatabaseInfoTierA10 DatabaseInfoTier = "A10"

	DatabaseInfoTierA20 DatabaseInfoTier = "A20"

	DatabaseInfoTierA40 DatabaseInfoTier = "A40"

	DatabaseInfoTierA5 DatabaseInfoTier = "A5"

	DatabaseInfoTierC10 DatabaseInfoTier = "C10"

	DatabaseInfoTierC20 DatabaseInfoTier = "C20"

	DatabaseInfoTierC40 DatabaseInfoTier = "C40"

	DatabaseInfoTierD10 DatabaseInfoTier = "D10"

	DatabaseInfoTierD20 DatabaseInfoTier = "D20"

	DatabaseInfoTierD40 DatabaseInfoTier = "D40"

	DatabaseInfoTierDeveloper DatabaseInfoTier = "developer"
)

// Defines values for DatabaseInfoCreateCloudProvider.
const (
	DatabaseInfoCreateCloudProviderAWS DatabaseInfoCreateCloudProvider = "AWS"

	DatabaseInfoCreateCloudProviderAZURE DatabaseInfoCreateCloudProvider = "AZURE"

	DatabaseInfoCreateCloudProviderGCP DatabaseInfoCreateCloudProvider = "GCP"
)

// Defines values for DatabaseInfoCreateTier.
const (
	DatabaseInfoCreateTierA10 DatabaseInfoCreateTier = "A10"

	DatabaseInfoCreateTierA20 DatabaseInfoCreateTier = "A20"

	DatabaseInfoCreateTierA40 DatabaseInfoCreateTier = "A40"

	DatabaseInfoCreateTierA5 DatabaseInfoCreateTier = "A5"

	DatabaseInfoCreateTierC10 DatabaseInfoCreateTier = "C10"

	DatabaseInfoCreateTierC20 DatabaseInfoCreateTier = "C20"

	DatabaseInfoCreateTierC40 DatabaseInfoCreateTier = "C40"

	DatabaseInfoCreateTierD10 DatabaseInfoCreateTier = "D10"

	DatabaseInfoCreateTierD20 DatabaseInfoCreateTier = "D20"

	DatabaseInfoCreateTierD40 DatabaseInfoCreateTier = "D40"

	DatabaseInfoCreateTierDeveloper DatabaseInfoCreateTier = "developer"
)

// Defines values for PolicyActions.
const (
	PolicyActionsDbAllKeyspaceCreate PolicyActions = "db-all-keyspace-create"

	PolicyActionsDbAllKeyspaceDescribe PolicyActions = "db-all-keyspace-describe"

	PolicyActionsDbCql PolicyActions = "db-cql"

	PolicyActionsDbGraphql PolicyActions = "db-graphql"

	PolicyActionsDbKeyspaceAlter PolicyActions = "db-keyspace-alter"

	PolicyActionsDbKeyspaceAuthorize PolicyActions = "db-keyspace-authorize"

	PolicyActionsDbKeyspaceCreate PolicyActions = "db-keyspace-create"

	PolicyActionsDbKeyspaceDescribe PolicyActions = "db-keyspace-describe"

	PolicyActionsDbKeyspaceDrop PolicyActions = "db-keyspace-drop"

	PolicyActionsDbKeyspaceGrant PolicyActions = "db-keyspace-grant"

	PolicyActionsDbKeyspaceModify PolicyActions = "db-keyspace-modify"

	PolicyActionsDbRest PolicyActions = "db-rest"

	PolicyActionsDbTableAlter PolicyActions = "db-table-alter"

	PolicyActionsDbTableAuthorize PolicyActions = "db-table-authorize"

	PolicyActionsDbTableCreate PolicyActions = "db-table-create"

	PolicyActionsDbTableDescribe PolicyActions = "db-table-describe"

	PolicyActionsDbTableDrop PolicyActions = "db-table-drop"

	PolicyActionsDbTableGrant PolicyActions = "db-table-grant"

	PolicyActionsDbTableModify PolicyActions = "db-table-modify"

	PolicyActionsDbTableSelect PolicyActions = "db-table-select"

	PolicyActionsOrgAuditsRead PolicyActions = "org-audits-read"

	PolicyActionsOrgBillingRead PolicyActions = "org-billing-read"

	PolicyActionsOrgBillingWrite PolicyActions = "org-billing-write"

	PolicyActionsOrgDbAddpeering PolicyActions = "org-db-addpeering"

	PolicyActionsOrgDbCreate PolicyActions = "org-db-create"

	PolicyActionsOrgDbExpand PolicyActions = "org-db-expand"

	PolicyActionsOrgDbManagemigratorproxy PolicyActions = "org-db-managemigratorproxy"

	PolicyActionsOrgDbPasswordreset PolicyActions = "org-db-passwordreset"

	PolicyActionsOrgDbSuspend PolicyActions = "org-db-suspend"

	PolicyActionsOrgDbTerminate PolicyActions = "org-db-terminate"

	PolicyActionsOrgDbView PolicyActions = "org-db-view"

	PolicyActionsOrgExternalAuthRead PolicyActions = "org-external-auth-read"

	PolicyActionsOrgExternalAuthWrite PolicyActions = "org-external-auth-write"

	PolicyActionsOrgNotificationWrite PolicyActions = "org-notification-write"

	PolicyActionsOrgRead PolicyActions = "org-read"

	PolicyActionsOrgRoleDelete PolicyActions = "org-role-delete"

	PolicyActionsOrgRoleRead PolicyActions = "org-role-read"

	PolicyActionsOrgRoleWrite PolicyActions = "org-role-write"

	PolicyActionsOrgTokenRead PolicyActions = "org-token-read"

	PolicyActionsOrgTokenWrite PolicyActions = "org-token-write"

	PolicyActionsOrgUserRead PolicyActions = "org-user-read"

	PolicyActionsOrgUserWrite PolicyActions = "org-user-write"

	PolicyActionsOrgWrite PolicyActions = "org-write"
)

// Defines values for PolicyEffect.
const (
	PolicyEffectAllow PolicyEffect = "allow"
)

// Defines values for StatusEnum.
const (
	StatusEnumACTIVE StatusEnum = "ACTIVE"

	StatusEnumERROR StatusEnum = "ERROR"

	StatusEnumINITIALIZING StatusEnum = "INITIALIZING"

	StatusEnumMAINTENANCE StatusEnum = "MAINTENANCE"

	StatusEnumPARKED StatusEnum = "PARKED"

	StatusEnumPARKING StatusEnum = "PARKING"

	StatusEnumPENDING StatusEnum = "PENDING"

	StatusEnumPREPARED StatusEnum = "PREPARED"

	StatusEnumPREPARING StatusEnum = "PREPARING"

	StatusEnumRESIZING StatusEnum = "RESIZING"

	StatusEnumSUSPENDED StatusEnum = "SUSPENDED"

	StatusEnumTERMINATED StatusEnum = "TERMINATED"

	StatusEnumTERMINATING StatusEnum = "TERMINATING"

	StatusEnumUNKNOWN StatusEnum = "UNKNOWN"

	StatusEnumUNPARKING StatusEnum = "UNPARKING"
)

// AvailableRegionCombination defines a Tier, cloud provider, region combination
type AvailableRegionCombination struct {
	CapacityUnitsLimit              int    `json:"capacityUnitsLimit"`
	CapacityUnitsUsed               int    `json:"capacityUnitsUsed"`
	CloudProvider                   string `json:"cloudProvider"`
	Cost                            Costs  `json:"cost"`
	DatabaseCountLimit              int    `json:"databaseCountLimit"`
	DatabaseCountUsed               int    `json:"databaseCountUsed"`
	DefaultStoragePerCapacityUnitGb int    `json:"defaultStoragePerCapacityUnitGb"`
	Region                          string `json:"region"`
	Tier                            string `json:"tier"`
}

// CapacityUnits is used to horizontally scale a database.
type CapacityUnits struct {

	// CapacityUnits can be increased by a max of three additional capacity units per operation. Reducing capacity units is not supported at this time
	CapacityUnits *int `json:"capacityUnits,omitempty"`
}

// An individual clientID and associated roles
type ClientRole struct {

	// the clientID
	ClientId *string   `json:"clientId,omitempty"`
	Roles    *[]string `json:"roles,omitempty"`
}

// The response for a requested token
type ClientRoleList struct {

	// a list of clientId and associated soles
	Clients *[]ClientRole `json:"clients,omitempty"`
}

// Costs defines model for Costs.
type Costs struct {
	CostPerDayCents         *float64 `json:"costPerDayCents,omitempty"`
	CostPerDayParkedCents   *float64 `json:"costPerDayParkedCents,omitempty"`
	CostPerHourCents        *float64 `json:"costPerHourCents,omitempty"`
	CostPerHourParkedCents  *float64 `json:"costPerHourParkedCents,omitempty"`
	CostPerMinCents         *float64 `json:"costPerMinCents,omitempty"`
	CostPerMinParkedCents   *float64 `json:"costPerMinParkedCents,omitempty"`
	CostPerMonthCents       *float64 `json:"costPerMonthCents,omitempty"`
	CostPerMonthParkedCents *float64 `json:"costPerMonthParkedCents,omitempty"`
}

// The createRole model
type CreateRoleRequest struct {
	Name string `json:"name"`

	// A policy for a role in Astra.
	Policy Policy `json:"policy"`
}

// CredsURL from which the creds zip may be downloaded
type CredsURL struct {

	// DownloadURL is only valid for about 5 minutes
	DownloadURL string `json:"downloadURL"`

	// Internal DownloadURL is only valid for about 5 minutes
	DownloadURLInternal *string `json:"downloadURLInternal,omitempty"`

	// Migration Proxy DownloadURL is only valid for about 5 minutes
	DownloadURLMigrationProxy *string `json:"downloadURLMigrationProxy,omitempty"`

	// Internal Migration Proxy DownloadURL is only valid for about 5 minutes
	DownloadURLMigrationProxyInternal *string `json:"downloadURLMigrationProxyInternal,omitempty"`
}

// Database contains the key information about a database
type Database struct {
	AvailableActions *[]DatabaseAvailableActions `json:"availableActions,omitempty"`
	CqlshUrl         *string                     `json:"cqlshUrl,omitempty"`

	// CreationTime in ISO RFC3339 format
	CreationTime    *string `json:"creationTime,omitempty"`
	DataEndpointUrl *string `json:"dataEndpointUrl,omitempty"`
	GrafanaUrl      *string `json:"grafanaUrl,omitempty"`
	GraphqlUrl      *string `json:"graphqlUrl,omitempty"`
	Id              string  `json:"id"`

	// DatabaseInfo is the user-provided information describing a database
	Info DatabaseInfo `json:"info"`

	// Message to the customer about the cluster
	Message *string    `json:"message,omitempty"`
	OrgId   string     `json:"orgId"`
	OwnerId string     `json:"ownerId"`
	Status  StatusEnum `json:"status"`

	// Storage contains the information about how much storage space a cluster has available
	Storage   *Storage `json:"storage,omitempty"`
	StudioUrl *string  `json:"studioUrl,omitempty"`

	// TerminationTime in ISO RFC3339 format
	TerminationTime *string `json:"terminationTime,omitempty"`
}

// DatabaseAvailableActions defines model for Database.AvailableActions.
type DatabaseAvailableActions string

// DatabaseInfo is the user-provided information describing a database
type DatabaseInfo struct {

	// Additional keyspaces names in database
	AdditionalKeyspaces *[]string `json:"additionalKeyspaces,omitempty"`

	// CapacityUnits is the amount of space available (horizontal scaling) for the database. For free tier the max CU's is 1, and 12 for C10 the max is 12 on startup.
	CapacityUnits *int `json:"capacityUnits,omitempty"`

	// CloudProvider where the database lives
	CloudProvider *DatabaseInfoCloudProvider `json:"cloudProvider,omitempty"`

	// Keyspace name in database
	Keyspace *string `json:"keyspace,omitempty"`

	// Name of the database--user friendly identifier
	Name *string `json:"name,omitempty"`

	// Password for the user to access the database
	Password *string `json:"password,omitempty"`

	// Region refers to the cloud region.
	Region *string `json:"region,omitempty"`

	// Tier defines the compute power (vertical scaling) for the database
	Tier *DatabaseInfoTier `json:"tier,omitempty"`

	// User is the user to access the database
	User *string `json:"user,omitempty"`
}

// CloudProvider where the database lives
type DatabaseInfoCloudProvider string

// Tier defines the compute power (vertical scaling) for the database
type DatabaseInfoTier string

// DatabaseInfo is the user-provided information describing a database
type DatabaseInfoCreate struct {

	// CapacityUnits is the amount of space available (horizontal scaling) for the database. For free tier the max CU's is 1, and 100 for CXX/DXX the max is 12 on startup.
	CapacityUnits int `json:"capacityUnits"`

	// CloudProvider where the database lives
	CloudProvider DatabaseInfoCreateCloudProvider `json:"cloudProvider"`

	// Keyspace name in database
	Keyspace string `json:"keyspace"`

	// Name of the database--user friendly identifier
	Name string `json:"name"`

	// Password for the user to access the database
	Password string `json:"password"`

	// Region refers to the cloud region.
	Region string `json:"region"`

	// Tier defines the compute power (vertical scaling) for the database, developer gcp is the free tier.
	Tier DatabaseInfoCreateTier `json:"tier"`

	// User is the user to access the database
	User string `json:"user"`
}

// CloudProvider where the database lives
type DatabaseInfoCreateCloudProvider string

// Tier defines the compute power (vertical scaling) for the database, developer gcp is the free tier.
type DatabaseInfoCreateTier string

// ModelError information that is returned to users
type Error struct {

	// API specific error code
	ID *int `json:"ID,omitempty"`

	// User-friendly description of error
	Message string `json:"message"`
}

// Errors is a collection of individual Error objects
type Errors struct {
	Errors []Error `json:"errors"`
}

// The post body to generate a token
type GenerateTokenBody struct {

	// The roles for which the token will be generated
	Roles []string `json:"roles"`
}

// The response for a requested token
type GenerateTokenResponse struct {

	// The id of the client (uuid)
	ClientId string `json:"clientId"`

	// the UUID of the organization
	OrgId string `json:"orgId"`

	// The roles for which the token will be generated
	Roles []string `json:"roles"`

	// The secret token
	Secret string `json:"secret"`

	// AstraCS:clientId:hex(sha256(secret))
	Token *string `json:"token,omitempty"`
}

// Configuration of the migration proxy and mappings of astra node to a customer node currently in use
type MigrationProxyConfiguration struct {
	Mappings []MigrationProxyMapping `json:"mappings"`

	// origin cassandra password
	OriginPassword string `json:"originPassword"`

	// origin cassandra username
	OriginUsername string `json:"originUsername"`
}

// A mapping of astra node to a customer node currently in use
type MigrationProxyMapping struct {

	// ip on which the node currently in use is accessible
	OriginIP string `json:"originIP"`

	// port on which the node currently in use is accessible
	OriginPort int `json:"originPort"`

	// the number of the rack, usually 0, 1, or 2
	Rack int `json:"rack"`

	// The number of the node in a given rack, starting with 0
	RackNodeOrdinal int `json:"rackNodeOrdinal"`
}

// An organization
type Organization struct {

	// The organization UUID
	Id string `json:"id"`
}

// A policy for a role in Astra.
type Policy struct {

	// The actions this policy can take. Example Actions: 'org-billing-write' 'db-keyspace-create'
	Actions []PolicyActions `json:"actions"`

	// A description of this policy
	Description string `json:"description"`

	// Effect this policy will have on the provided resource
	Effect PolicyEffect `json:"effect"`

	// The resources this policy can manipulate.
	Resources []string `json:"resources"`
}

// PolicyActions defines model for Policy.Actions.
type PolicyActions string

// Effect this policy will have on the provided resource
type PolicyEffect string

// Details of a user role and its policy details
type Role struct {

	// The unique system generated identifier of the role.
	Id *string `json:"id,omitempty"`

	// The date and time of the last update on the role.
	LastUpdateDatetime *time.Time `json:"last_update_datetime,omitempty"`

	// The userID of the user who last updated the role.
	LastUpdateUserid *string `json:"last_update_userid,omitempty"`

	// The name of the role.
	Name *string `json:"name,omitempty"`

	// A policy for a role in Astra.
	Policy *Policy `json:"policy,omitempty"`
}

// an array of roles
type Roles []Role

// ServiceAccountTokenInput defines model for ServiceAccountTokenInput.
type ServiceAccountTokenInput struct {

	// The unique identifier for the client for authentication
	ClientId string `json:"clientId"`

	// The organization name in a more human readable format
	ClientName string `json:"clientName"`

	// The UUID client secret for the service account from the create service account response in the user interface
	ClientSecret string `json:"clientSecret"`
}

// ServiceAccountTokenResponse defines model for ServiceAccountTokenResponse.
type ServiceAccountTokenResponse struct {

	// JWT that will be used as Authorization header on all requests requiring authentication.
	Token *string `json:"token,omitempty"`
}

// StatusEnum defines model for StatusEnum.
type StatusEnum string

// Storage contains the information about how much storage space a cluster has available
type Storage struct {

	// NodeCount for the cluster
	NodeCount int `json:"nodeCount"`

	// ReplicationFactor is the number of nodes storing a piece of data
	ReplicationFactor int `json:"replicationFactor"`

	// TotalStorage of the cluster in GB
	TotalStorage int `json:"totalStorage"`

	// UsedStorage in GB
	UsedStorage *int `json:"usedStorage,omitempty"`
}

// The updateRole model
type UpdateRoleRequest struct {
	Name string `json:"name"`

	// A policy for a role in Astra.
	Policy Policy `json:"policy"`
}

// UserPassword specifies a username and new password. The specified password will be updated for the specified database user
type UserPassword struct {

	// New password (min 6 characters)
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// ClientIdParam defines model for ClientIdParam.
type ClientIdParam string

// DatabaseIdParam defines model for DatabaseIdParam.
type DatabaseIdParam string

// KeyspaceNameParam defines model for KeyspaceNameParam.
type KeyspaceNameParam string

// RoleIdParam defines model for RoleIdParam.
type RoleIdParam string

// Errors is a collection of individual Error objects
type BadRequest Errors

// Errors is a collection of individual Error objects
type Conflict Errors

// Errors is a collection of individual Error objects
type Forbidden Errors

// Errors is a collection of individual Error objects
type NotFound Errors

// Errors is a collection of individual Error objects
type ServerError Errors

// Errors is a collection of individual Error objects
type Unauthorized Errors

// Errors is a collection of individual Error objects
type UnprocessableEntity Errors

// AuthenticateServiceAccountTokenJSONBody defines parameters for AuthenticateServiceAccountToken.
type AuthenticateServiceAccountTokenJSONBody ServiceAccountTokenInput

// GenerateTokenForClientJSONBody defines parameters for GenerateTokenForClient.
type GenerateTokenForClientJSONBody GenerateTokenBody

// ListDatabasesParams defines parameters for ListDatabases.
type ListDatabasesParams struct {

	// Allows filtering so that databases in listed states are returned
	Include *ListDatabasesParamsInclude `json:"include,omitempty"`

	// Allows filtering so that databases from a given provider are returned
	Provider *ListDatabasesParamsProvider `json:"provider,omitempty"`

	// Optional parameter for pagination purposes. Used as this value for starting retrieving a specific page of results
	StartingAfter *string `json:"starting_after,omitempty"`

	// Optional parameter for pagination purposes. Specify the number of items for one page of data
	Limit *int `json:"limit,omitempty"`
}

// ListDatabasesParamsInclude defines parameters for ListDatabases.
type ListDatabasesParamsInclude string

// ListDatabasesParamsProvider defines parameters for ListDatabases.
type ListDatabasesParamsProvider string

// CreateDatabaseJSONBody defines parameters for CreateDatabase.
type CreateDatabaseJSONBody DatabaseInfoCreate

// LaunchMigrationProxyJSONBody defines parameters for LaunchMigrationProxy.
type LaunchMigrationProxyJSONBody MigrationProxyConfiguration

// ResetPasswordJSONBody defines parameters for ResetPassword.
type ResetPasswordJSONBody UserPassword

// ResizeDatabaseJSONBody defines parameters for ResizeDatabase.
type ResizeDatabaseJSONBody CapacityUnits

// SuspendDatabaseParams defines parameters for SuspendDatabase.
type SuspendDatabaseParams struct {

	// Represents, from 0 to 100, the free credits percentage consumed.
	FreeConsumed *int `json:"freeConsumed,omitempty"`
}

// TerminateDatabaseParams defines parameters for TerminateDatabase.
type TerminateDatabaseParams struct {

	// For internal use only.  Used to safely terminate prepared databases.
	PreparedStateOnly *bool `json:"preparedStateOnly,omitempty"`
}

// AddOrganizationRoleJSONBody defines parameters for AddOrganizationRole.
type AddOrganizationRoleJSONBody CreateRoleRequest

// UpdateRoleJSONBody defines parameters for UpdateRole.
type UpdateRoleJSONBody UpdateRoleRequest

// AuthenticateServiceAccountTokenJSONRequestBody defines body for AuthenticateServiceAccountToken for application/json ContentType.
type AuthenticateServiceAccountTokenJSONRequestBody AuthenticateServiceAccountTokenJSONBody

// GenerateTokenForClientJSONRequestBody defines body for GenerateTokenForClient for application/json ContentType.
type GenerateTokenForClientJSONRequestBody GenerateTokenForClientJSONBody

// CreateDatabaseJSONRequestBody defines body for CreateDatabase for application/json ContentType.
type CreateDatabaseJSONRequestBody CreateDatabaseJSONBody

// LaunchMigrationProxyJSONRequestBody defines body for LaunchMigrationProxy for application/json ContentType.
type LaunchMigrationProxyJSONRequestBody LaunchMigrationProxyJSONBody

// ResetPasswordJSONRequestBody defines body for ResetPassword for application/json ContentType.
type ResetPasswordJSONRequestBody ResetPasswordJSONBody

// ResizeDatabaseJSONRequestBody defines body for ResizeDatabase for application/json ContentType.
type ResizeDatabaseJSONRequestBody ResizeDatabaseJSONBody

// AddOrganizationRoleJSONRequestBody defines body for AddOrganizationRole for application/json ContentType.
type AddOrganizationRoleJSONRequestBody AddOrganizationRoleJSONBody

// UpdateRoleJSONRequestBody defines body for UpdateRole for application/json ContentType.
type UpdateRoleJSONRequestBody UpdateRoleJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AuthenticateServiceAccountToken request  with any body
	AuthenticateServiceAccountTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthenticateServiceAccountToken(ctx context.Context, body AuthenticateServiceAccountTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAvailableRegions request
	ListAvailableRegions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientsForOrg request
	GetClientsForOrg(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateTokenForClient request  with any body
	GenerateTokenForClientWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateTokenForClient(ctx context.Context, body GenerateTokenForClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTokenForClient request
	DeleteTokenForClient(ctx context.Context, clientId ClientIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentOrganization request
	GetCurrentOrganization(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDatabases request
	ListDatabases(ctx context.Context, params *ListDatabasesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDatabase request  with any body
	CreateDatabaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDatabase(ctx context.Context, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatabase request
	GetDatabase(ctx context.Context, databaseID DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddKeyspace request
	AddKeyspace(ctx context.Context, databaseID DatabaseIdParam, keyspaceName KeyspaceNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMigrationProxy request
	RemoveMigrationProxy(ctx context.Context, databaseID DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LaunchMigrationProxy request  with any body
	LaunchMigrationProxyWithBody(ctx context.Context, databaseID DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LaunchMigrationProxy(ctx context.Context, databaseID DatabaseIdParam, body LaunchMigrationProxyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ParkDatabase request
	ParkDatabase(ctx context.Context, databaseID DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetPassword request  with any body
	ResetPasswordWithBody(ctx context.Context, databaseID DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResetPassword(ctx context.Context, databaseID DatabaseIdParam, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResizeDatabase request  with any body
	ResizeDatabaseWithBody(ctx context.Context, databaseID DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResizeDatabase(ctx context.Context, databaseID DatabaseIdParam, body ResizeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateSecureBundleURL request
	GenerateSecureBundleURL(ctx context.Context, databaseID DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SuspendDatabase request
	SuspendDatabase(ctx context.Context, databaseID DatabaseIdParam, params *SuspendDatabaseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TerminateDatabase request
	TerminateDatabase(ctx context.Context, databaseID DatabaseIdParam, params *TerminateDatabaseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnparkDatabase request
	UnparkDatabase(ctx context.Context, databaseID DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationRoles request
	GetOrganizationRoles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddOrganizationRole request  with any body
	AddOrganizationRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddOrganizationRole(ctx context.Context, body AddOrganizationRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOrganizationRole request
	DeleteOrganizationRole(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationRole request
	GetOrganizationRole(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRole request  with any body
	UpdateRoleWithBody(ctx context.Context, roleID RoleIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRole(ctx context.Context, roleID RoleIdParam, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AuthenticateServiceAccountTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticateServiceAccountTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticateServiceAccountToken(ctx context.Context, body AuthenticateServiceAccountTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticateServiceAccountTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAvailableRegions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAvailableRegionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientsForOrg(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientsForOrgRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateTokenForClientWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateTokenForClientRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateTokenForClient(ctx context.Context, body GenerateTokenForClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateTokenForClientRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTokenForClient(ctx context.Context, clientId ClientIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTokenForClientRequest(c.Server, clientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentOrganization(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentOrganizationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDatabases(ctx context.Context, params *ListDatabasesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDatabasesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabase(ctx context.Context, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatabase(ctx context.Context, databaseID DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatabaseRequest(c.Server, databaseID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddKeyspace(ctx context.Context, databaseID DatabaseIdParam, keyspaceName KeyspaceNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddKeyspaceRequest(c.Server, databaseID, keyspaceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMigrationProxy(ctx context.Context, databaseID DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMigrationProxyRequest(c.Server, databaseID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LaunchMigrationProxyWithBody(ctx context.Context, databaseID DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLaunchMigrationProxyRequestWithBody(c.Server, databaseID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LaunchMigrationProxy(ctx context.Context, databaseID DatabaseIdParam, body LaunchMigrationProxyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLaunchMigrationProxyRequest(c.Server, databaseID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ParkDatabase(ctx context.Context, databaseID DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewParkDatabaseRequest(c.Server, databaseID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPasswordWithBody(ctx context.Context, databaseID DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordRequestWithBody(c.Server, databaseID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPassword(ctx context.Context, databaseID DatabaseIdParam, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordRequest(c.Server, databaseID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResizeDatabaseWithBody(ctx context.Context, databaseID DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResizeDatabaseRequestWithBody(c.Server, databaseID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResizeDatabase(ctx context.Context, databaseID DatabaseIdParam, body ResizeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResizeDatabaseRequest(c.Server, databaseID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateSecureBundleURL(ctx context.Context, databaseID DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateSecureBundleURLRequest(c.Server, databaseID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SuspendDatabase(ctx context.Context, databaseID DatabaseIdParam, params *SuspendDatabaseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSuspendDatabaseRequest(c.Server, databaseID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TerminateDatabase(ctx context.Context, databaseID DatabaseIdParam, params *TerminateDatabaseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTerminateDatabaseRequest(c.Server, databaseID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnparkDatabase(ctx context.Context, databaseID DatabaseIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnparkDatabaseRequest(c.Server, databaseID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationRoles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationRolesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrganizationRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrganizationRoleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrganizationRole(ctx context.Context, body AddOrganizationRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrganizationRoleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrganizationRole(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrganizationRoleRequest(c.Server, roleID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationRole(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationRoleRequest(c.Server, roleID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoleWithBody(ctx context.Context, roleID RoleIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleRequestWithBody(c.Server, roleID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRole(ctx context.Context, roleID RoleIdParam, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleRequest(c.Server, roleID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAuthenticateServiceAccountTokenRequest calls the generic AuthenticateServiceAccountToken builder with application/json body
func NewAuthenticateServiceAccountTokenRequest(server string, body AuthenticateServiceAccountTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthenticateServiceAccountTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthenticateServiceAccountTokenRequestWithBody generates requests for AuthenticateServiceAccountToken with any type of body
func NewAuthenticateServiceAccountTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/authenticateServiceAccount")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAvailableRegionsRequest generates requests for ListAvailableRegions
func NewListAvailableRegionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/availableRegions")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClientsForOrgRequest generates requests for GetClientsForOrg
func NewGetClientsForOrgRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/clientIdSecrets")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateTokenForClientRequest calls the generic GenerateTokenForClient builder with application/json body
func NewGenerateTokenForClientRequest(server string, body GenerateTokenForClientJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateTokenForClientRequestWithBody(server, "application/json", bodyReader)
}

// NewGenerateTokenForClientRequestWithBody generates requests for GenerateTokenForClient with any type of body
func NewGenerateTokenForClientRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/clientIdSecrets")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTokenForClientRequest generates requests for DeleteTokenForClient
func NewDeleteTokenForClientRequest(server string, clientId ClientIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/clientIdSecrets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentOrganizationRequest generates requests for GetCurrentOrganization
func NewGetCurrentOrganizationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/currentOrg")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDatabasesRequest generates requests for ListDatabases
func NewListDatabasesRequest(server string, params *ListDatabasesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Provider != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "provider", runtime.ParamLocationQuery, *params.Provider); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartingAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDatabaseRequest calls the generic CreateDatabase builder with application/json body
func NewCreateDatabaseRequest(server string, body CreateDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDatabaseRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDatabaseRequestWithBody generates requests for CreateDatabase with any type of body
func NewCreateDatabaseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDatabaseRequest generates requests for GetDatabase
func NewGetDatabaseRequest(server string, databaseID DatabaseIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseID", runtime.ParamLocationPath, databaseID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddKeyspaceRequest generates requests for AddKeyspace
func NewAddKeyspaceRequest(server string, databaseID DatabaseIdParam, keyspaceName KeyspaceNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseID", runtime.ParamLocationPath, databaseID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "keyspaceName", runtime.ParamLocationPath, keyspaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/keyspaces/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveMigrationProxyRequest generates requests for RemoveMigrationProxy
func NewRemoveMigrationProxyRequest(server string, databaseID DatabaseIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseID", runtime.ParamLocationPath, databaseID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/migrationProxy", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLaunchMigrationProxyRequest calls the generic LaunchMigrationProxy builder with application/json body
func NewLaunchMigrationProxyRequest(server string, databaseID DatabaseIdParam, body LaunchMigrationProxyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLaunchMigrationProxyRequestWithBody(server, databaseID, "application/json", bodyReader)
}

// NewLaunchMigrationProxyRequestWithBody generates requests for LaunchMigrationProxy with any type of body
func NewLaunchMigrationProxyRequestWithBody(server string, databaseID DatabaseIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseID", runtime.ParamLocationPath, databaseID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/migrationProxy", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewParkDatabaseRequest generates requests for ParkDatabase
func NewParkDatabaseRequest(server string, databaseID DatabaseIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseID", runtime.ParamLocationPath, databaseID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/park", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResetPasswordRequest calls the generic ResetPassword builder with application/json body
func NewResetPasswordRequest(server string, databaseID DatabaseIdParam, body ResetPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResetPasswordRequestWithBody(server, databaseID, "application/json", bodyReader)
}

// NewResetPasswordRequestWithBody generates requests for ResetPassword with any type of body
func NewResetPasswordRequestWithBody(server string, databaseID DatabaseIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseID", runtime.ParamLocationPath, databaseID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/resetPassword", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResizeDatabaseRequest calls the generic ResizeDatabase builder with application/json body
func NewResizeDatabaseRequest(server string, databaseID DatabaseIdParam, body ResizeDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResizeDatabaseRequestWithBody(server, databaseID, "application/json", bodyReader)
}

// NewResizeDatabaseRequestWithBody generates requests for ResizeDatabase with any type of body
func NewResizeDatabaseRequestWithBody(server string, databaseID DatabaseIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseID", runtime.ParamLocationPath, databaseID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/resize", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenerateSecureBundleURLRequest generates requests for GenerateSecureBundleURL
func NewGenerateSecureBundleURLRequest(server string, databaseID DatabaseIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseID", runtime.ParamLocationPath, databaseID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/secureBundleURL", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSuspendDatabaseRequest generates requests for SuspendDatabase
func NewSuspendDatabaseRequest(server string, databaseID DatabaseIdParam, params *SuspendDatabaseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseID", runtime.ParamLocationPath, databaseID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/suspend", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.FreeConsumed != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "freeConsumed", runtime.ParamLocationQuery, *params.FreeConsumed); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTerminateDatabaseRequest generates requests for TerminateDatabase
func NewTerminateDatabaseRequest(server string, databaseID DatabaseIdParam, params *TerminateDatabaseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseID", runtime.ParamLocationPath, databaseID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/terminate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.PreparedStateOnly != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preparedStateOnly", runtime.ParamLocationQuery, *params.PreparedStateOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnparkDatabaseRequest generates requests for UnparkDatabase
func NewUnparkDatabaseRequest(server string, databaseID DatabaseIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseID", runtime.ParamLocationPath, databaseID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/databases/%s/unpark", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationRolesRequest generates requests for GetOrganizationRoles
func NewGetOrganizationRolesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/roles")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddOrganizationRoleRequest calls the generic AddOrganizationRole builder with application/json body
func NewAddOrganizationRoleRequest(server string, body AddOrganizationRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddOrganizationRoleRequestWithBody(server, "application/json", bodyReader)
}

// NewAddOrganizationRoleRequestWithBody generates requests for AddOrganizationRole with any type of body
func NewAddOrganizationRoleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/roles")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOrganizationRoleRequest generates requests for DeleteOrganizationRole
func NewDeleteOrganizationRoleRequest(server string, roleID RoleIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleID", runtime.ParamLocationPath, roleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationRoleRequest generates requests for GetOrganizationRole
func NewGetOrganizationRoleRequest(server string, roleID RoleIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleID", runtime.ParamLocationPath, roleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRoleRequest calls the generic UpdateRole builder with application/json body
func NewUpdateRoleRequest(server string, roleID RoleIdParam, body UpdateRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRoleRequestWithBody(server, roleID, "application/json", bodyReader)
}

// NewUpdateRoleRequestWithBody generates requests for UpdateRole with any type of body
func NewUpdateRoleRequestWithBody(server string, roleID RoleIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleID", runtime.ParamLocationPath, roleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/organizations/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AuthenticateServiceAccountToken request  with any body
	AuthenticateServiceAccountTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthenticateServiceAccountTokenResponse, error)

	AuthenticateServiceAccountTokenWithResponse(ctx context.Context, body AuthenticateServiceAccountTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticateServiceAccountTokenResponse, error)

	// ListAvailableRegions request
	ListAvailableRegionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAvailableRegionsResponse, error)

	// GetClientsForOrg request
	GetClientsForOrgWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClientsForOrgResponse, error)

	// GenerateTokenForClient request  with any body
	GenerateTokenForClientWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateTokenForClientResponse, error)

	GenerateTokenForClientWithResponse(ctx context.Context, body GenerateTokenForClientJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateTokenForClientResponse, error)

	// DeleteTokenForClient request
	DeleteTokenForClientWithResponse(ctx context.Context, clientId ClientIdParam, reqEditors ...RequestEditorFn) (*DeleteTokenForClientResponse, error)

	// GetCurrentOrganization request
	GetCurrentOrganizationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentOrganizationResponse, error)

	// ListDatabases request
	ListDatabasesWithResponse(ctx context.Context, params *ListDatabasesParams, reqEditors ...RequestEditorFn) (*ListDatabasesResponse, error)

	// CreateDatabase request  with any body
	CreateDatabaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error)

	CreateDatabaseWithResponse(ctx context.Context, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error)

	// GetDatabase request
	GetDatabaseWithResponse(ctx context.Context, databaseID DatabaseIdParam, reqEditors ...RequestEditorFn) (*GetDatabaseResponse, error)

	// AddKeyspace request
	AddKeyspaceWithResponse(ctx context.Context, databaseID DatabaseIdParam, keyspaceName KeyspaceNameParam, reqEditors ...RequestEditorFn) (*AddKeyspaceResponse, error)

	// RemoveMigrationProxy request
	RemoveMigrationProxyWithResponse(ctx context.Context, databaseID DatabaseIdParam, reqEditors ...RequestEditorFn) (*RemoveMigrationProxyResponse, error)

	// LaunchMigrationProxy request  with any body
	LaunchMigrationProxyWithBodyWithResponse(ctx context.Context, databaseID DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LaunchMigrationProxyResponse, error)

	LaunchMigrationProxyWithResponse(ctx context.Context, databaseID DatabaseIdParam, body LaunchMigrationProxyJSONRequestBody, reqEditors ...RequestEditorFn) (*LaunchMigrationProxyResponse, error)

	// ParkDatabase request
	ParkDatabaseWithResponse(ctx context.Context, databaseID DatabaseIdParam, reqEditors ...RequestEditorFn) (*ParkDatabaseResponse, error)

	// ResetPassword request  with any body
	ResetPasswordWithBodyWithResponse(ctx context.Context, databaseID DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error)

	ResetPasswordWithResponse(ctx context.Context, databaseID DatabaseIdParam, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error)

	// ResizeDatabase request  with any body
	ResizeDatabaseWithBodyWithResponse(ctx context.Context, databaseID DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResizeDatabaseResponse, error)

	ResizeDatabaseWithResponse(ctx context.Context, databaseID DatabaseIdParam, body ResizeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*ResizeDatabaseResponse, error)

	// GenerateSecureBundleURL request
	GenerateSecureBundleURLWithResponse(ctx context.Context, databaseID DatabaseIdParam, reqEditors ...RequestEditorFn) (*GenerateSecureBundleURLResponse, error)

	// SuspendDatabase request
	SuspendDatabaseWithResponse(ctx context.Context, databaseID DatabaseIdParam, params *SuspendDatabaseParams, reqEditors ...RequestEditorFn) (*SuspendDatabaseResponse, error)

	// TerminateDatabase request
	TerminateDatabaseWithResponse(ctx context.Context, databaseID DatabaseIdParam, params *TerminateDatabaseParams, reqEditors ...RequestEditorFn) (*TerminateDatabaseResponse, error)

	// UnparkDatabase request
	UnparkDatabaseWithResponse(ctx context.Context, databaseID DatabaseIdParam, reqEditors ...RequestEditorFn) (*UnparkDatabaseResponse, error)

	// GetOrganizationRoles request
	GetOrganizationRolesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOrganizationRolesResponse, error)

	// AddOrganizationRole request  with any body
	AddOrganizationRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrganizationRoleResponse, error)

	AddOrganizationRoleWithResponse(ctx context.Context, body AddOrganizationRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrganizationRoleResponse, error)

	// DeleteOrganizationRole request
	DeleteOrganizationRoleWithResponse(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*DeleteOrganizationRoleResponse, error)

	// GetOrganizationRole request
	GetOrganizationRoleWithResponse(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*GetOrganizationRoleResponse, error)

	// UpdateRole request  with any body
	UpdateRoleWithBodyWithResponse(ctx context.Context, roleID RoleIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error)

	UpdateRoleWithResponse(ctx context.Context, roleID RoleIdParam, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error)
}

type AuthenticateServiceAccountTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceAccountTokenResponse
	JSON400      *Errors
	JSON401      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r AuthenticateServiceAccountTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthenticateServiceAccountTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAvailableRegionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AvailableRegionCombination
	JSON401      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r ListAvailableRegionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAvailableRegionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientsForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *Errors
	JSON403      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r GetClientsForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientsForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateTokenForClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *Errors
	JSON403      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r GenerateTokenForClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateTokenForClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTokenForClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON403      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r DeleteTokenForClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTokenForClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *Errors
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r GetCurrentOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDatabasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Database
	JSON400      *Errors
	JSON401      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r ListDatabasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDatabasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON401      *Errors
	JSON422      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r CreateDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Database
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r GetDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddKeyspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Errors
	JSON404      *Errors
	JSON422      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r AddKeyspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddKeyspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMigrationProxyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r RemoveMigrationProxyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMigrationProxyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LaunchMigrationProxyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r LaunchMigrationProxyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LaunchMigrationProxyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ParkDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r ParkDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ParkDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r ResetPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResizeDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r ResizeDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResizeDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateSecureBundleURLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CredsURL
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r GenerateSecureBundleURLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateSecureBundleURLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SuspendDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r SuspendDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SuspendDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TerminateDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r TerminateDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TerminateDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnparkDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON401      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON5XX      *Errors
}

// Status returns HTTPResponse.Status
func (r UnparkDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnparkDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r GetOrganizationRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddOrganizationRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Role
	JSON400      *Errors
	JSON403      *Errors
	JSON404      *Errors
	JSON409      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r AddOrganizationRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddOrganizationRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOrganizationRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r DeleteOrganizationRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOrganizationRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *Errors
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r GetOrganizationRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Errors
	JSON403      *Errors
	JSON404      *Errors
	JSON500      *Errors
}

// Status returns HTTPResponse.Status
func (r UpdateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AuthenticateServiceAccountTokenWithBodyWithResponse request with arbitrary body returning *AuthenticateServiceAccountTokenResponse
func (c *ClientWithResponses) AuthenticateServiceAccountTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthenticateServiceAccountTokenResponse, error) {
	rsp, err := c.AuthenticateServiceAccountTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticateServiceAccountTokenResponse(rsp)
}

func (c *ClientWithResponses) AuthenticateServiceAccountTokenWithResponse(ctx context.Context, body AuthenticateServiceAccountTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticateServiceAccountTokenResponse, error) {
	rsp, err := c.AuthenticateServiceAccountToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticateServiceAccountTokenResponse(rsp)
}

// ListAvailableRegionsWithResponse request returning *ListAvailableRegionsResponse
func (c *ClientWithResponses) ListAvailableRegionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAvailableRegionsResponse, error) {
	rsp, err := c.ListAvailableRegions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAvailableRegionsResponse(rsp)
}

// GetClientsForOrgWithResponse request returning *GetClientsForOrgResponse
func (c *ClientWithResponses) GetClientsForOrgWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClientsForOrgResponse, error) {
	rsp, err := c.GetClientsForOrg(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientsForOrgResponse(rsp)
}

// GenerateTokenForClientWithBodyWithResponse request with arbitrary body returning *GenerateTokenForClientResponse
func (c *ClientWithResponses) GenerateTokenForClientWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateTokenForClientResponse, error) {
	rsp, err := c.GenerateTokenForClientWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateTokenForClientResponse(rsp)
}

func (c *ClientWithResponses) GenerateTokenForClientWithResponse(ctx context.Context, body GenerateTokenForClientJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateTokenForClientResponse, error) {
	rsp, err := c.GenerateTokenForClient(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateTokenForClientResponse(rsp)
}

// DeleteTokenForClientWithResponse request returning *DeleteTokenForClientResponse
func (c *ClientWithResponses) DeleteTokenForClientWithResponse(ctx context.Context, clientId ClientIdParam, reqEditors ...RequestEditorFn) (*DeleteTokenForClientResponse, error) {
	rsp, err := c.DeleteTokenForClient(ctx, clientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTokenForClientResponse(rsp)
}

// GetCurrentOrganizationWithResponse request returning *GetCurrentOrganizationResponse
func (c *ClientWithResponses) GetCurrentOrganizationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentOrganizationResponse, error) {
	rsp, err := c.GetCurrentOrganization(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentOrganizationResponse(rsp)
}

// ListDatabasesWithResponse request returning *ListDatabasesResponse
func (c *ClientWithResponses) ListDatabasesWithResponse(ctx context.Context, params *ListDatabasesParams, reqEditors ...RequestEditorFn) (*ListDatabasesResponse, error) {
	rsp, err := c.ListDatabases(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDatabasesResponse(rsp)
}

// CreateDatabaseWithBodyWithResponse request with arbitrary body returning *CreateDatabaseResponse
func (c *ClientWithResponses) CreateDatabaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error) {
	rsp, err := c.CreateDatabaseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseResponse(rsp)
}

func (c *ClientWithResponses) CreateDatabaseWithResponse(ctx context.Context, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error) {
	rsp, err := c.CreateDatabase(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseResponse(rsp)
}

// GetDatabaseWithResponse request returning *GetDatabaseResponse
func (c *ClientWithResponses) GetDatabaseWithResponse(ctx context.Context, databaseID DatabaseIdParam, reqEditors ...RequestEditorFn) (*GetDatabaseResponse, error) {
	rsp, err := c.GetDatabase(ctx, databaseID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatabaseResponse(rsp)
}

// AddKeyspaceWithResponse request returning *AddKeyspaceResponse
func (c *ClientWithResponses) AddKeyspaceWithResponse(ctx context.Context, databaseID DatabaseIdParam, keyspaceName KeyspaceNameParam, reqEditors ...RequestEditorFn) (*AddKeyspaceResponse, error) {
	rsp, err := c.AddKeyspace(ctx, databaseID, keyspaceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddKeyspaceResponse(rsp)
}

// RemoveMigrationProxyWithResponse request returning *RemoveMigrationProxyResponse
func (c *ClientWithResponses) RemoveMigrationProxyWithResponse(ctx context.Context, databaseID DatabaseIdParam, reqEditors ...RequestEditorFn) (*RemoveMigrationProxyResponse, error) {
	rsp, err := c.RemoveMigrationProxy(ctx, databaseID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMigrationProxyResponse(rsp)
}

// LaunchMigrationProxyWithBodyWithResponse request with arbitrary body returning *LaunchMigrationProxyResponse
func (c *ClientWithResponses) LaunchMigrationProxyWithBodyWithResponse(ctx context.Context, databaseID DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LaunchMigrationProxyResponse, error) {
	rsp, err := c.LaunchMigrationProxyWithBody(ctx, databaseID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLaunchMigrationProxyResponse(rsp)
}

func (c *ClientWithResponses) LaunchMigrationProxyWithResponse(ctx context.Context, databaseID DatabaseIdParam, body LaunchMigrationProxyJSONRequestBody, reqEditors ...RequestEditorFn) (*LaunchMigrationProxyResponse, error) {
	rsp, err := c.LaunchMigrationProxy(ctx, databaseID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLaunchMigrationProxyResponse(rsp)
}

// ParkDatabaseWithResponse request returning *ParkDatabaseResponse
func (c *ClientWithResponses) ParkDatabaseWithResponse(ctx context.Context, databaseID DatabaseIdParam, reqEditors ...RequestEditorFn) (*ParkDatabaseResponse, error) {
	rsp, err := c.ParkDatabase(ctx, databaseID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseParkDatabaseResponse(rsp)
}

// ResetPasswordWithBodyWithResponse request with arbitrary body returning *ResetPasswordResponse
func (c *ClientWithResponses) ResetPasswordWithBodyWithResponse(ctx context.Context, databaseID DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error) {
	rsp, err := c.ResetPasswordWithBody(ctx, databaseID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordResponse(rsp)
}

func (c *ClientWithResponses) ResetPasswordWithResponse(ctx context.Context, databaseID DatabaseIdParam, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error) {
	rsp, err := c.ResetPassword(ctx, databaseID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordResponse(rsp)
}

// ResizeDatabaseWithBodyWithResponse request with arbitrary body returning *ResizeDatabaseResponse
func (c *ClientWithResponses) ResizeDatabaseWithBodyWithResponse(ctx context.Context, databaseID DatabaseIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResizeDatabaseResponse, error) {
	rsp, err := c.ResizeDatabaseWithBody(ctx, databaseID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResizeDatabaseResponse(rsp)
}

func (c *ClientWithResponses) ResizeDatabaseWithResponse(ctx context.Context, databaseID DatabaseIdParam, body ResizeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*ResizeDatabaseResponse, error) {
	rsp, err := c.ResizeDatabase(ctx, databaseID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResizeDatabaseResponse(rsp)
}

// GenerateSecureBundleURLWithResponse request returning *GenerateSecureBundleURLResponse
func (c *ClientWithResponses) GenerateSecureBundleURLWithResponse(ctx context.Context, databaseID DatabaseIdParam, reqEditors ...RequestEditorFn) (*GenerateSecureBundleURLResponse, error) {
	rsp, err := c.GenerateSecureBundleURL(ctx, databaseID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateSecureBundleURLResponse(rsp)
}

// SuspendDatabaseWithResponse request returning *SuspendDatabaseResponse
func (c *ClientWithResponses) SuspendDatabaseWithResponse(ctx context.Context, databaseID DatabaseIdParam, params *SuspendDatabaseParams, reqEditors ...RequestEditorFn) (*SuspendDatabaseResponse, error) {
	rsp, err := c.SuspendDatabase(ctx, databaseID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSuspendDatabaseResponse(rsp)
}

// TerminateDatabaseWithResponse request returning *TerminateDatabaseResponse
func (c *ClientWithResponses) TerminateDatabaseWithResponse(ctx context.Context, databaseID DatabaseIdParam, params *TerminateDatabaseParams, reqEditors ...RequestEditorFn) (*TerminateDatabaseResponse, error) {
	rsp, err := c.TerminateDatabase(ctx, databaseID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTerminateDatabaseResponse(rsp)
}

// UnparkDatabaseWithResponse request returning *UnparkDatabaseResponse
func (c *ClientWithResponses) UnparkDatabaseWithResponse(ctx context.Context, databaseID DatabaseIdParam, reqEditors ...RequestEditorFn) (*UnparkDatabaseResponse, error) {
	rsp, err := c.UnparkDatabase(ctx, databaseID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnparkDatabaseResponse(rsp)
}

// GetOrganizationRolesWithResponse request returning *GetOrganizationRolesResponse
func (c *ClientWithResponses) GetOrganizationRolesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOrganizationRolesResponse, error) {
	rsp, err := c.GetOrganizationRoles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationRolesResponse(rsp)
}

// AddOrganizationRoleWithBodyWithResponse request with arbitrary body returning *AddOrganizationRoleResponse
func (c *ClientWithResponses) AddOrganizationRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrganizationRoleResponse, error) {
	rsp, err := c.AddOrganizationRoleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrganizationRoleResponse(rsp)
}

func (c *ClientWithResponses) AddOrganizationRoleWithResponse(ctx context.Context, body AddOrganizationRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrganizationRoleResponse, error) {
	rsp, err := c.AddOrganizationRole(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrganizationRoleResponse(rsp)
}

// DeleteOrganizationRoleWithResponse request returning *DeleteOrganizationRoleResponse
func (c *ClientWithResponses) DeleteOrganizationRoleWithResponse(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*DeleteOrganizationRoleResponse, error) {
	rsp, err := c.DeleteOrganizationRole(ctx, roleID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrganizationRoleResponse(rsp)
}

// GetOrganizationRoleWithResponse request returning *GetOrganizationRoleResponse
func (c *ClientWithResponses) GetOrganizationRoleWithResponse(ctx context.Context, roleID RoleIdParam, reqEditors ...RequestEditorFn) (*GetOrganizationRoleResponse, error) {
	rsp, err := c.GetOrganizationRole(ctx, roleID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationRoleResponse(rsp)
}

// UpdateRoleWithBodyWithResponse request with arbitrary body returning *UpdateRoleResponse
func (c *ClientWithResponses) UpdateRoleWithBodyWithResponse(ctx context.Context, roleID RoleIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error) {
	rsp, err := c.UpdateRoleWithBody(ctx, roleID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleResponse(rsp)
}

func (c *ClientWithResponses) UpdateRoleWithResponse(ctx context.Context, roleID RoleIdParam, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error) {
	rsp, err := c.UpdateRole(ctx, roleID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleResponse(rsp)
}

// ParseAuthenticateServiceAccountTokenResponse parses an HTTP response from a AuthenticateServiceAccountTokenWithResponse call
func ParseAuthenticateServiceAccountTokenResponse(rsp *http.Response) (*AuthenticateServiceAccountTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AuthenticateServiceAccountTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceAccountTokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseListAvailableRegionsResponse parses an HTTP response from a ListAvailableRegionsWithResponse call
func ParseListAvailableRegionsResponse(rsp *http.Response) (*ListAvailableRegionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListAvailableRegionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AvailableRegionCombination
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetClientsForOrgResponse parses an HTTP response from a GetClientsForOrgWithResponse call
func ParseGetClientsForOrgResponse(rsp *http.Response) (*GetClientsForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetClientsForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGenerateTokenForClientResponse parses an HTTP response from a GenerateTokenForClientWithResponse call
func ParseGenerateTokenForClientResponse(rsp *http.Response) (*GenerateTokenForClientResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GenerateTokenForClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTokenForClientResponse parses an HTTP response from a DeleteTokenForClientWithResponse call
func ParseDeleteTokenForClientResponse(rsp *http.Response) (*DeleteTokenForClientResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteTokenForClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCurrentOrganizationResponse parses an HTTP response from a GetCurrentOrganizationWithResponse call
func ParseGetCurrentOrganizationResponse(rsp *http.Response) (*GetCurrentOrganizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListDatabasesResponse parses an HTTP response from a ListDatabasesWithResponse call
func ParseListDatabasesResponse(rsp *http.Response) (*ListDatabasesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListDatabasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Database
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseCreateDatabaseResponse parses an HTTP response from a CreateDatabaseWithResponse call
func ParseCreateDatabaseResponse(rsp *http.Response) (*CreateDatabaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDatabaseResponse parses an HTTP response from a GetDatabaseWithResponse call
func ParseGetDatabaseResponse(rsp *http.Response) (*GetDatabaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Database
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseAddKeyspaceResponse parses an HTTP response from a AddKeyspaceWithResponse call
func ParseAddKeyspaceResponse(rsp *http.Response) (*AddKeyspaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AddKeyspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseRemoveMigrationProxyResponse parses an HTTP response from a RemoveMigrationProxyWithResponse call
func ParseRemoveMigrationProxyResponse(rsp *http.Response) (*RemoveMigrationProxyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RemoveMigrationProxyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseLaunchMigrationProxyResponse parses an HTTP response from a LaunchMigrationProxyWithResponse call
func ParseLaunchMigrationProxyResponse(rsp *http.Response) (*LaunchMigrationProxyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &LaunchMigrationProxyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseParkDatabaseResponse parses an HTTP response from a ParkDatabaseWithResponse call
func ParseParkDatabaseResponse(rsp *http.Response) (*ParkDatabaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ParkDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseResetPasswordResponse parses an HTTP response from a ResetPasswordWithResponse call
func ParseResetPasswordResponse(rsp *http.Response) (*ResetPasswordResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ResetPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseResizeDatabaseResponse parses an HTTP response from a ResizeDatabaseWithResponse call
func ParseResizeDatabaseResponse(rsp *http.Response) (*ResizeDatabaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ResizeDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGenerateSecureBundleURLResponse parses an HTTP response from a GenerateSecureBundleURLWithResponse call
func ParseGenerateSecureBundleURLResponse(rsp *http.Response) (*GenerateSecureBundleURLResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GenerateSecureBundleURLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CredsURL
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseSuspendDatabaseResponse parses an HTTP response from a SuspendDatabaseWithResponse call
func ParseSuspendDatabaseResponse(rsp *http.Response) (*SuspendDatabaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SuspendDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseTerminateDatabaseResponse parses an HTTP response from a TerminateDatabaseWithResponse call
func ParseTerminateDatabaseResponse(rsp *http.Response) (*TerminateDatabaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &TerminateDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseUnparkDatabaseResponse parses an HTTP response from a UnparkDatabaseWithResponse call
func ParseUnparkDatabaseResponse(rsp *http.Response) (*UnparkDatabaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UnparkDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetOrganizationRolesResponse parses an HTTP response from a GetOrganizationRolesWithResponse call
func ParseGetOrganizationRolesResponse(rsp *http.Response) (*GetOrganizationRolesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddOrganizationRoleResponse parses an HTTP response from a AddOrganizationRoleWithResponse call
func ParseAddOrganizationRoleResponse(rsp *http.Response) (*AddOrganizationRoleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AddOrganizationRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteOrganizationRoleResponse parses an HTTP response from a DeleteOrganizationRoleWithResponse call
func ParseDeleteOrganizationRoleResponse(rsp *http.Response) (*DeleteOrganizationRoleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteOrganizationRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOrganizationRoleResponse parses an HTTP response from a GetOrganizationRoleWithResponse call
func ParseGetOrganizationRoleResponse(rsp *http.Response) (*GetOrganizationRoleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRoleResponse parses an HTTP response from a UpdateRoleWithResponse call
func ParseUpdateRoleResponse(rsp *http.Response) (*UpdateRoleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
